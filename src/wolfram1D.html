<!-- Wolfram's Nearest Neighbor 1D Simulation Page -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">  <!-- Set the character encoding to UTF-8 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  <!-- Define the viewport for responsive design -->
    <title> Discrete Mathematical Systems </title>
    <link rel="stylesheet" type="text/css" href="../styles/global.css">  <!-- Link to global CSS styles -->
    <link rel="stylesheet" type="text/css" href="../styles/wolfram1D.css">  <!-- Link to home specific CSS styles -->
  </head>
  <body>
    <!-- Navigation Bar-->
    <header>
      <div class="navbar">
        <a href="../src/index.html"> Home </a>  <!-- Link to the home page -->
        <!-- Dropdown menu for simulators -->
        <div class="dropdown">
          <button class="drop_button"> Simulators <i class="fa fa-caret-down"> </i> </button>
          <!-- Dropdown items -->
          <div class="dropdown_item">
            <a href="../src/wolfram1D.html"> 1D Nearest Neighbor </a>  <!-- Link to Wolfram's Nearest Neighbor 1D Simulation Page -->
            <a href="../src/wolfram2D.html"> 2D Nearest Neighbor </a>  <!-- Link to Wolfram's Nearest Neighbor 2D Simulation Page -->
            <a href="../src/conway.html"> Game of Life </a>  <!-- Link to Conway's Game of Life Simulation Page -->
          </div>
        </div>
        <a href="../src/documentation.html"> Documentation </a>  <!-- Link to the documentation page -->
        <a href="../src/index.html"> Source </a>  <!-- Link to the source code page -->
        <a href="../src/about.html"> About </a>  <!-- Link to the about page -->
      </div>
    </header>
    <h1> Wolfram's Nearest Neighbor 1D </h1> <hr>
    <!-- Primary tool bar containing main buttons for simulation -->
    <div class="primary_toolbar">
      <div class="input_container">
        <label for="inputBox1" class="input_label"> Iterations:</label>
        <input type="text" id="inputBox1" class="simulation_input" placeholder="Enter # of iterations...">
        <button id="submitButton1" class="submit_button"> Enter </button>
      </div>
      <!-- Container for rule input box -->
      <div class="input_container">
        <label for="inputBox2" class="input_label"> Rule: </label>
        <input type="text" id="inputBox2" class="simulation_input" placeholder="Enter rule # (0-255)...">
        <button id="submitButton2" class="submit_button"> Enter </button>
      </div>
      <!-- Container for lattice size input box -->
      <div class="input_container">
        <label for="inputBox3" class="input_label"> Lattice Size: </label>
        <input type="text" id="inputBox3" class="simulation_input" placeholder="Enter lattice size...">
        <button id="submitButton3" class="submit_button"> Enter </button>
      </div>
      <!-- Container for finite/infinite toggle bar -->
      <div class="input_container">
        <!-- Create Toggle bar and use Javascript function to handle click -->
        <label class="toggle_label"> Infinite </label>
        <div class="toggle_bar" onclick="toggleCheckbox()">
          <div class="toggle_button"> </div>
        </div>
        <label class="toggle_label"> Finite </label>
      </div>
      <!-- Create periodic checkbox -->
      <div class="checkbox_container" id="checkbox1">
        <input type="checkbox" class="checkbox_select">
        <label class="checkbox_label"> Periodic </label>
      </div>
      <!-- Create null checkbox -->
      <div class="checkbox_container" id="checkbox2">
        <input type="checkbox" class="checkbox_select">
        <label class="checkbox_label"> Null </label>
      </div>
    </div>
    <!-- Secondary tool bar containing input boxes and options to manipulate the simulation -->
    <div class="secondary_toolbar">
      <!-- Container for iteration input box -->
      <button id="primaryButton1" class="simulation_button"> Start </button>
      <button id="primaryButton2" class="simulation_button"> Stop </button>
      <button id="primaryButton3" class="simulation_button"> Iterate </button>
      <button id="primaryButton4" class="simulation_button"> Clear </button>
      <button id="primaryButton5" class="simulation_button"> Download </button>
      <button id="primaryButton6" class="simulation_button"> About </button>
      <canvas id="logRegion" class="log_box"> </canvas>  <!-- Display region for the logs -->
    </div>
    <div id="iterationOutput" class="iteration_output"></div>  <!-- Output region for iteration count -->
    <center> <canvas id="latticeRegion" class="lattice_region"> </canvas> </center>  <!-- Display region for the lattices -->
    <div id="aboutContainer" class="about_container">
      <div id="aboutContent" class="about_content">
        <span class="close">&times; </span>
        <h2> About Wolfram's Nearest Neighbor 1D Simulator </h2>
        <h3> Summary </h3>
        <p> 
          In the context of cellular automaton, the Nearest Neighbor algorithm can be applied to determine the state transition 
          rules for each cell based on the states of its neighboring cells in the lattice. A cell, in mathematics, is a basic unit
          within a lattice, or rather, a rectangular grid consisting of discrete cells arranged in rows and columns, forming a
          multi-dimensional grid that acts as a spatial framework for cellular automaton evolution. Each cell typically
          has a finite number of possible states, and the evolution of the cellular automaton is determined by rules
          that govern cell state change over time by using neighboring cell states. A cell state specifically refers to the
          condition or value associated with a cell within a cellular automaton, commonly represented in binary states (dead/alive),
          which is used for this simulation. The grid structure allows for the simulation of dynamic systems and the emergence of
          complex behaviors from simple local rules, in this case, rules 0-255 (2^8 rules). The rules change how the neighboring cells
          (left and right) determine the next cell state. The simulation can be completed with varying rule sets, lattice sizes, and
          iterations and and each alteration will produce a unique result. Additionally, the Nearest Neighbor algorithm can be done with
          a finite or infinite lattice, such that an infinite lattice is unbounded in respect to neighbors where out of bound neighbors
          are 0 and become bounded, and a finite lattice must be handled with null boundaries (cells outside of the lattice bounds have
          no influence on the evolution of the system) or periodic boundaries (edges of the lattice wrap around to connect with the opposite edge).
          Overall, cellular automaton are discrete computational models composed of a grid of cells that iteratively evolve using a set mathematical rule.        
        </p>
      </div>
    </div>
    <!-- Connect online Javascript library to capture canvas as a PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.4.1/jspdf.debug.js"></script>
    <script src= "../src/js/generateLattice.js"> </script>  <!-- Connect Javascript for lattice calculation -->
    <script src="../src/js/cellClass.js"> </script>  <!-- Connect Javascript for cell creation -->
    <script src= "../src/js/displayLattice.js"> </script>  <!-- Connect Javascript for lattice display -->
    <script src="../src/js/UIFunctionality.js"> </script>  <!-- Connect Javascript for user interface -->
  </body>
</html>
